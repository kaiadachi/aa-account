{"version":3,"file":"account.js","sourceRoot":"","sources":["../../../src/light-account/account.ts"],"names":[],"mappings":";;;AAAA,8CAK0B;AAC1B,+BASc;AACd,kEAA4D;AAC5D,gFAA0E;AAE1E,MAAa,yBAEX,SAAQ,oCAAsC;IACrC,KAAK,CAAC,aAAa,CAAC,MAA2B;QACtD,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;IAC1C,CAAC;IAOD,KAAK,CAAC,eAAe;QACnB,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;YAC7C,EAAE,EAAE,MAAM,IAAI,CAAC,UAAU,EAAE;YAC3B,IAAI,EAAE,IAAA,yBAAkB,EAAC;gBACvB,GAAG,EAAE,oCAAe;gBACpB,YAAY,EAAE,OAAO;aACtB,CAAC;SACH,CAAC,CAAC;QAEH,IAAI,UAAU,CAAC,IAAI,IAAI,IAAI,EAAE;YAC3B,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SACjD;QAED,MAAM,iBAAiB,GAAG,IAAA,2BAAoB,EAAC;YAC7C,GAAG,EAAE,oCAAe;YACpB,YAAY,EAAE,OAAO;YACrB,IAAI,EAAE,UAAU,CAAC,IAAI;SACtB,CAAC,CAAC;QAEH,IAAI,iBAAiB,KAAK,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC,EAAE;YACzD,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;SAChE;QAED,OAAO,iBAAiB,CAAC;IAC3B,CAAC;IAQD,MAAM,CAAC,uBAAuB,CAAC,QAAiB;QAC9C,OAAO,IAAA,yBAAkB,EAAC;YACxB,GAAG,EAAE,oCAAe;YACpB,YAAY,EAAE,mBAAmB;YACjC,IAAI,EAAE,CAAC,QAAQ,CAAC;SACjB,CAAC,CAAC;IACL,CAAC;IAWD,MAAM,CAAC,KAAK,CAAC,iBAAiB,CAG5B,QAEC,EACD,QAA4B,EAC5B,aAAsB,KAAK;QAE3B,MAAM,IAAI,GAAG,IAAI,CAAC,uBAAuB,CAAC,MAAM,QAAQ,CAAC,UAAU,EAAE,CAAC,CAAC;QACvE,MAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,iBAAiB,CAAC;YAC9C,MAAM,EAAE,MAAM,QAAQ,CAAC,UAAU,EAAE;YACnC,IAAI;SACL,CAAC,CAAC;QAEH,QAAQ,CAAC,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC;QAElC,IAAI,UAAU,EAAE;YACd,OAAO,QAAQ,CAAC,+BAA+B,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SAC9D;QAED,OAAO,MAAM,CAAC,IAAI,CAAC;IACrB,CAAC;IAEkB,KAAK,CAAC,kBAAkB;QACzC,OAAO,IAAA,gBAAS,EAAC;YACf,IAAI,CAAC,cAAc;YACnB,IAAA,yBAAkB,EAAC;gBACjB,GAAG,EAAE,kDAAsB;gBAC3B,YAAY,EAAE,eAAe;gBAE7B,IAAI,EAAE,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,EAAE,EAAE,CAAC;aAC1C,CAAC;SACH,CAAC,CAAC;IACL,CAAC;CACF;AAhGD,8DAgGC","sourcesContent":["import {\n  SimpleSmartContractAccount,\n  SmartAccountProvider,\n  type SignTypedDataParams,\n  type SmartAccountSigner,\n} from \"@alchemy/aa-core\";\nimport {\n  concatHex,\n  decodeFunctionResult,\n  encodeFunctionData,\n  type Address,\n  type FallbackTransport,\n  type Hash,\n  type Hex,\n  type Transport,\n} from \"viem\";\nimport { LightAccountAbi } from \"./abis/LightAccountAbi.js\";\nimport { LightAccountFactoryAbi } from \"./abis/LightAccountFactoryAbi.js\";\n\nexport class LightSmartContractAccount<\n  TTransport extends Transport | FallbackTransport = Transport\n> extends SimpleSmartContractAccount<TTransport> {\n  override async signTypedData(params: SignTypedDataParams): Promise<Hash> {\n    return this.owner.signTypedData(params);\n  }\n\n  /**\n   * Returns the on-chain EOA owner address of the account.\n   *\n   * @returns {Address} the on-chain EOA owner of the account\n   */\n  async getOwnerAddress(): Promise<Address> {\n    const callResult = await this.rpcProvider.call({\n      to: await this.getAddress(),\n      data: encodeFunctionData({\n        abi: LightAccountAbi,\n        functionName: \"owner\",\n      }),\n    });\n\n    if (callResult.data == null) {\n      throw new Error(\"could not get on-chain owner\");\n    }\n\n    const decodedCallResult = decodeFunctionResult({\n      abi: LightAccountAbi,\n      functionName: \"owner\",\n      data: callResult.data,\n    });\n\n    if (decodedCallResult !== (await this.owner.getAddress())) {\n      throw new Error(\"on-chain owner does not match account owner\");\n    }\n\n    return decodedCallResult;\n  }\n\n  /**\n   * Encodes the transferOwnership function call using Light Account ABI.\n   *\n   * @param newOwner - the new owner of the account\n   * @returns {Hex} the encoded function call\n   */\n  static encodeTransferOwnership(newOwner: Address): Hex {\n    return encodeFunctionData({\n      abi: LightAccountAbi,\n      functionName: \"transferOwnership\",\n      args: [newOwner],\n    });\n  }\n\n  /**\n   * Transfers ownership of the account to the newOwner on-chain and also updates the owner of the account.\n   * Optionally waits for the transaction to be mined.\n   *\n   * @param provider - the provider to use to send the transaction\n   * @param newOwner - the new owner of the account\n   * @param waitForTxn - whether or not to wait for the transaction to be mined\n   * @returns {Hash} the userOperation hash, or transaction hash if `waitForTxn` is true\n   */\n  static async transferOwnership<\n    TTransport extends Transport | FallbackTransport = Transport\n  >(\n    provider: SmartAccountProvider<TTransport> & {\n      account: LightSmartContractAccount<TTransport>;\n    },\n    newOwner: SmartAccountSigner,\n    waitForTxn: boolean = false\n  ): Promise<Hash> {\n    const data = this.encodeTransferOwnership(await newOwner.getAddress());\n    const result = await provider.sendUserOperation({\n      target: await provider.getAddress(),\n      data,\n    });\n\n    provider.account.owner = newOwner;\n\n    if (waitForTxn) {\n      return provider.waitForUserOperationTransaction(result.hash);\n    }\n\n    return result.hash;\n  }\n\n  protected override async getAccountInitCode(): Promise<`0x${string}`> {\n    return concatHex([\n      this.factoryAddress,\n      encodeFunctionData({\n        abi: LightAccountFactoryAbi,\n        functionName: \"createAccount\",\n        // light account does not support sub-accounts\n        args: [await this.owner.getAddress(), 0n],\n      }),\n    ]);\n  }\n}\n"]}