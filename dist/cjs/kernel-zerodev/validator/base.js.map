{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../../src/kernel-zerodev/validator/base.ts"],"names":[],"mappings":";;;AACA,+BAA2C;AAE3C,IAAY,aAMX;AAND,WAAY,aAAa;IACvB,oCAAmB,CAAA;IACnB,sCAAqB,CAAA;AAIvB,CAAC,EANW,aAAa,6BAAb,aAAa,QAMxB;AAWD,MAAa,mBAAmB;IAK9B,YAAY,MAAiC;QAJpC;;;;;WAAsB;QAC/B;;;;;WAAoB;QACpB;;;;;WAA0B;QAGxB,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC;QAChD,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;QACxB,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;IAC5B,CAAC;IAED,UAAU;QACR,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED,KAAK,CAAC,eAAe;QACnB,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC;IACjC,CAAC;IACD,KAAK,CAAC,8BAA8B,CAClC,UAAqC;QAErC,IACE,IAAI,CAAC,IAAI,KAAK,aAAa,CAAC,IAAI;YAChC,IAAI,CAAC,IAAI,KAAK,aAAa,CAAC,MAAM,EAClC;YACA,IAAI;gBACF,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;gBAC3D,OAAO,IAAA,gBAAS,EAAC,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;aAC1C;YAAC,OAAO,GAAQ,EAAE;gBACjB,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,GAAG,CAAC,OAAO,CAAC,CAAC;gBACzC,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;aACrD;SACF;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SACjD;IACH,CAAC;CACF;AApCD,kDAoCC","sourcesContent":["import type { SmartAccountSigner } from \"@alchemy/aa-core\";\nimport { concatHex, type Hex } from \"viem\";\n\nexport enum ValidatorMode {\n  sudo = \"0x00000000\",\n  plugin = \"0x00000001\",\n\n  //To be enabled later\n  // enable = '0x00000002',\n}\n\nexport interface KernelBaseValidatorParams {\n  validatorAddress: Hex;\n  mode: ValidatorMode;\n  owner: SmartAccountSigner;\n}\n\n//Kernel wallet implementation separates out validation and execution phase. It allows you to have\n// custom wrapper logic for the validation phase in addition to signature of choice. We start with base validator class\n// which implements only signing but can be extended to other methods later\nexport class KernelBaseValidator {\n  readonly validatorAddress: Hex;\n  mode: ValidatorMode;\n  owner: SmartAccountSigner;\n\n  constructor(params: KernelBaseValidatorParams) {\n    this.validatorAddress = params.validatorAddress;\n    this.mode = params.mode;\n    this.owner = params.owner;\n  }\n\n  getAddress(): Hex {\n    return this.validatorAddress;\n  }\n\n  async getOwnerAddress(): Promise<Hex> {\n    return this.owner.getAddress();\n  }\n  async signMessageWithValidatorParams(\n    userOpHash: Uint8Array | string | Hex\n  ): Promise<Hex> {\n    if (\n      this.mode === ValidatorMode.sudo ||\n      this.mode === ValidatorMode.plugin\n    ) {\n      try {\n        const signature = await this.owner.signMessage(userOpHash);\n        return concatHex([this.mode, signature]);\n      } catch (err: any) {\n        console.log(\"Got Error - \", err.message);\n        throw new Error(\"Validator failed to sign message\");\n      }\n    } else {\n      throw new Error(\"Validator mode not supported\");\n    }\n  }\n}\n"]}